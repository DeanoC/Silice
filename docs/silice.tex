\documentclass[a4]{article}

\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{calc}

\newcommand\todo[1]{{\color{magenta}\textbf{TODO:} #1}}
\newcommand\verilog{Verilog}
\newcommand\silice{Silice}

% enamel

\title{\silice{}\\ \textit{\normalsize A low-level procedural programming language for FPGA}}

\begin{document}

\maketitle

\silice{} makes it possible to write algorithms for FPGAs in the same way we write them for processors: defining sequences of operations, subroutines that can be called, and using control flow statements such as \texttt{while} and \texttt{break} (even good old \texttt{goto}s are available!). 
At the same time, \silice{} \textit{remains low level}. Everything an algorithm does is precisely timed, you can fully exploit the parallelism and niceties of FPGA architectures, clock domains are exposed. 
\silice{} is only a thin layer above the hardware: nothing gets obfuscated away. In fact, \silice{} compiles to and inter-operates with \verilog{}: you can directly instantiate and bind with existing modules. When \verilog{} makes more sense, use it!

\silice{} is reminiscent of high performance programming in the late 90s (in the demo scene in particular): the then considered high-level C language was commonly interfaced with time-critical ASM routines. This enabled a best-of-both-worlds situation, with C being used for the overall program flow and ASM used only on carefully optimized hardware dependent routines.
%
\silice{} aims to do the same, providing a thin programmer friendly layer on top of \verilog{}, while allowing to call low level \verilog{} modules whenever needed.
\silice{} also favors and exposes parallelism, so as to fully utilize the FPGA architecture.\\

Oh, and it features a powerful LUA-based pre-processor.\\

%The main design principles are:
%\begin{itemize}
%\item Prioritize combinational over sequential execution. Parallelism comes first!
%\item Clearly defined rules regarding clock cycle consumption.
%\item Explicit clock domains and reset signals.
%\item Inter-operates easily with \verilog{}, allowing to import and reuse existing modules.
%\item Familiar C-like syntax.
%\item Powerful LUA-based pre-processor.
%\end{itemize}

\noindent While I developed \silice{} for my own needs, I hope you'll find it useful for your projects!

% ==============================================
	
\section{A first example}

This first example assumes two signals: a 'button' input (high when pressed) and a 'led' output, each one bit.

The \textit{main} algorithm -- the one expected as top level -- simply asks the led to turn on when the button is pressed. We will consider several versions -- all working -- to demonstrate basic features of \silice{}.

Perhaps the most natural version for a programmer not used to FPGAs would be:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(input uint1 button,output uint1 led) {  
  while (1) {
    led = button;
  }
}
\end{minted}
This sets 'led' to the value of 'button' every clock cycle.
%
However, we could instead specify a \textit{continuous assignment} between led and button:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(input uint1 button,output uint1 led) {  
  led := button;
}
\end{minted}

This makes 'led' constantly track the value of 'button'. A very convenient feature is that the continuous assignment can be overridden at some clock steps, for instance:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(input uint1 button,output uint1 led) {  
  led := 0;
  while (1) {
    if (button == 1) {
      led = 1;
    }
  }  
}
\end{minted}

Of course this last version is needlessly complicated (the previous one was minimal), but it shows the principle: 'led' is continuously assigned 0, but this will be overridden whenever the button is pressed. This is useful to maintain an output to a value that must change only on some specific event (e.g. producing a pulse).

% ==============================================

\tableofcontents

% ==============================================

\section{Terminology}
Some terminology we use next:
\begin{itemize}
\item \textbf{VIO}: a Variable, Input or Output.
\item \textbf{Combinational chain}: A chain of dependent operations implemented
as combinational hardware.
\item \textbf{Combinational loop}: A combinational chain where a cyclic dependency exists. These lead to unstable hardware synthesis and have to be avoided (but in a few rare cases).
\item \textbf{Host hardware framework}: The \verilog{} glue to the hardware meant to run the design. This can also be a glue to Icarus\footnote{http://iverilog.icarus.com/} or Verilator\footnote{https://www.veripool.org/wiki/verilator}, both frameworks are provided.
\end{itemize}

% ==============================================

\section{Basic language constructs}

\subsection{Types}
\label{sec:types}

\silice{} supports signed and unsigned integers with a specified bit width:

\begin{itemize}
	\item \texttt{int}N with N the bit-width, e.g. \texttt{int8}: signed integer.
	\item \texttt{uint}N with N the bit-width, e.g. \texttt{uint8}: unsigned integer.
\end{itemize}

\subsection{Constants}
\label{sec:csts}

Constants may be given directly as decimal based numbers (eg. \texttt{1234}), or
can be given with a specified bit width and base:
\begin{itemize}
	\item \texttt{3b0101}, 3 bits wide value 5.
	\item \texttt{32hffff}, 32 bits wide value 65535.
	\item \texttt{4d10}, 4 bits wide value 10.
\end{itemize}

Supported base identifiers are: \texttt{b} for binary, \texttt{h} for hexadecimal, \texttt{d} for decimal. If the value does not fit the bit width, it is clamped.

\subsection{Variables}

Variables are declared with the following pattern:

\texttt{TYPE ID = VALUE;}

\noindent where \texttt{TYPE} is a type definition (Section~\ref{sec:types}), \texttt{ID} a variable identifier (starting with a letter followed by alphanumeric or underscores) and \texttt{VALUE} a constant (Section~\ref{sec:csts}).

The initializer is mandatory, and is always a simple constant (no expressions).

\subsection{Tables}

\texttt{intN tbl[M] = \{...\} }

\noindent Example:  \texttt{int6 tbl[4] = \{0,0,0,0\};}

\noindent Table sizes have to be constant at compile time. The initializer is mandatory and can be a string, in which case each letter becomes its ASCII value, and the string is null terminated. The table size \texttt{M} is optional (eg. \texttt{int4 tbl[]=\{1,2,3\};} ) in which case the size is automatically derived from the initializer (strings have one additional implicit character: the null terminator).

\subsection{Operators}

\subsubsection{Swizzling}

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
int6 a = 0;
int1 b = a[1,1]; // second bit
int2 c = a[1,2]; // int2 with second and third bits
int3 d = a[2,3]; // int3 with third, fourth and fifth bits
\end{minted}

The first entry may be an expression, the second has to be a constant.

\subsubsection{Arithmetic, comparison, bit-wise, reduction, shift}

All standard verilog operators are supported, binary and unary.

\subsubsection{Concatenation}

Concatenation allows to combine expressions to form expressions having larger bit-width.
The syntax is to form a comma separated list enclosed by braces.  Example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
  int6  a = 6b111000;
  int2  b = 2b10;
  int10 c = 0;
  c := {b,a,2b11};
\end{minted}

Here c is obtained by concatenating a,b and the constant 2b11 to form a ten bits wide integer.

\subsubsection{Bindings}
\label{sec:bindings}

\silice{} defines operators for bindings the input/output of algorithms and modules:
\begin{itemize}
	\item \texttt{<:} binds right to left
	\item \texttt{:>} binds left to right
	\item \texttt{<:>} binds both ways % \todo{not yet implemented}
\end{itemize}

The bound sides have to be VIO identifiers. 
Bound VIOs are connected and immediately track each others values.
A good way to think of this is as a physical wire between IC pins, where each VIO is a pin.
Bindings are specified when instantiating algorithms and modules. 

The bidirectional binding is reserved for \texttt{inout} variables, which currently can only be
passed through \silice{} to \verilog{} modules.

\subsubsection{Continuous assignment}
\label{sec:contassign}

\silice{} defines operators for continuous assignment of VIOs.
A continuous assignment is performed at each clock rising edge, regardless of the 
execution state of the algorithm. The left side of the assignment has to be a VIO identifier,
while the right side may be an expression.
\begin{itemize}
\item \texttt{:=} assign right to left at each rising clock.
\item \texttt{::=} assign right to left with a one clock cycle delay (two stages flip-flop).
\end{itemize}

Continuous assignments are specified just after variable declarations and algorithms/modules instantiations.

% ==============================================

\section{Algorithms}

Algorithms are the main elements of a \silice{} design. An algorithm is a specification of a circuit implementation. Thus, like modules in \verilog{}, algorithms have to be instanced before being used. Each instance becomes an actual physical layout on the final design.
An algorithm can instance other algorithms and \verilog{} modules. 

Instanced algorithms \textit{always run in parallel}. However they can be called synchronously (implying a wait state in the caller). They may run forever and start automatically. Each may be driven from a specific clock and reset signal.

\paragraph{main (entry point).}
The top level algorithm is called \textit{main} and has to be defined. It is automatically instanced by the \textit{host hardware framework}, see Section~\ref{sec:host}.

% -----------------------

\subsection{Declaration}

An algorithm is declared as follows:
\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
algorithm ID (
input TYPE ID
...
output TYPE ID
...
output! TYPE ID
...
) <MODS> {
  DECLARATIONS
  SUBROUTINES
  CONTINUOUS_ASSIGNMENTS
  INSTRUCTIONS
}
\end{minted}

Most elements are optional: the number of inputs and outputs can vary, the modifiers may be empty (in which case the \texttt{'<>'} is not necessary) and declarations, bindings and instructions may all be empty.

Here is a simple example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm adder(intput uint8 a,intput uint8 b,output uint8 v)
{
  v = a + b;
}
\end{minted}

\noindent Let us now discuss each element of the declaration.

% -----------------------

\paragraph{Inputs and outputs.}

Inputs and outputs may be declared in any order, however the order matters when calling the algorithms (parameters are given in the order of inputs, results are read back in the order of outputs). Input and outputs can be single variables or tables.
A third type \texttt{inout} exists for compatibility with \verilog{} modules, however these can only be passed and bound to imported modules (i.e. they cannot be used in expressions and instructions for now).

Note that there are two types of output: \texttt{output} and \texttt{output!}. These distinguish between a standard and a combinational output (exclamation mark). A standard output sees its value updated at the next clock cycle. A combinational output ensures that callers sees the results within the same combinational chain. This is for instance important when implementing a video driver; e.g. a HDMI module generates a pixel coordinate on its output and expects to see the corresponding color on its input within the same clock step. Thus, the algorithm outputting the color to the HDMI driver will input the coordinate and use \texttt{output!} for the color. However, using only \texttt{output!} will in some cases result in combinational loops, leading to unstable circuits.

% ----------------------------------------------

\paragraph{Declarations.} Variables, instanced algorithms and instanced modules have to be declared first (in any order). A simple example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(output uint8 led)
{
  uint8 r = 0;
  adder ad1;
  
  // ... btw this is a comment
}
\end{minted}

% ----------------------------------------------

\subsection{Instantiation}
\label{sec:instantiation}

Algorithms and modules can be instanced from within a parent algorithm. Optionally parameters can be \textit{bound} to the parent algorithm variables. 
In terms of hardware, these are the wires connecting instanced and parent algorithms.
%
Instantiation uses the following syntax:
%
\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
MOD_ALG ID<@CLOCK,!RESET> (
BINDINGS
(<:auto:>)
);
\end{minted}
%
where \texttt{MOD\_ALG} is the name of the module/algorithm, \texttt{ID} an
identifier for the instance, and \texttt{BINDINGS} a comma separated list of 
bindings between the instance inputs/outputs and the parent algorithm variables.
The bindings are optional and may be partial.
\texttt{@CLOCK} optionally specifies a clock signal, \texttt{!RESET} a reset signal, where \texttt{CLOCK} and \texttt{RESET} have to be \texttt{uint1} variables in the parent algorithm. Both are optional, and if none is specified the brackets \texttt{<>} can be skipped. When none are specified the parent \texttt{clock} and \texttt{reset} are used for the instance.

Each binding is defined as:
\texttt{ID\_left OP ID\_right} 
where \texttt{ID\_left}
is the identifier of an instance input or output, \texttt{OP} a continuous
assignment operator (Section~\ref{sec:contassign}) and \texttt{ID\_right} a variable identifier.

Note that only identifiers are allowed in bindings: access to tables, swizzling and access to other algorithms input/output with the dot syntax are not allowed.

Combined with \texttt{autorun} such bindings allow to instantiate and immediately run an algorithm to drive some of the parent algorithm variables. 
Here is an example:
%
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm blink(output int1 b_fast,output int1 b_slow) <autorun>
{
  uint20 counter = 0;
  while (1) {
    counter = counter + 1;
      if (counter[0,8] == 0) {
        b_fast = !b_fast;
      }
      if (counter == 0) {
        b_slow = !b_slow;
      }
  }
}

algorithm main(output int8 led)
{
  int1 a = 0;
  int1 b = 0;
  blink b0(
    b_slow :> a,
    b_fast :> b
  );

  led := 0;      // turn off all eight LEDs
  led[0,1] := a; // first LED tracks slow blink
  led[1,1] := b; // second LED tracks fast blink

  while (1) { } // inifinite loop, blink runs in parallel
}
\end{minted}
%
This example reveals some interesting possibilities, and a constraint.
As algorithm \texttt{blink} is instanced as \texttt{b0}, it starts running immediately (due to the \texttt{autorun} modifier in the declaration of \texttt{blink}). Hence, the variables \texttt{a} and \texttt{b}
are immediately tracking the \texttt{b\_slow} and \texttt{b\_fast} outputs of \texttt{b0}. The continuous assignments to \texttt{led} then use \texttt{a} and \texttt{b} to output to the \texttt{led} 8-bit variable, which we assume is physically connected to LEDs. The first assignment sets \texttt{led} to zero, and then its two first bits to \texttt{a} and \texttt{b}. As the continuous assignments are order dependent, this behaves properly with the two first bits always assigned at each clock cycle. Since all updates in \texttt{main} are done through bindings and continuous assignments, and because \textit{algorithms always run in parallel}, there is nothing else to do, and \texttt{main} enters an infinite loop.

The constraint, however, is that \texttt{a} and \texttt{b} are necessary. This is due to the fact that we cannot directly bind \texttt{led[0,1]} and \texttt{led[1,1]} to the instance of \texttt{blink}. Only identifiers can be specified during binding.

\paragraph{Automatic binding.}
The optional \texttt{<:auto:>} tag allows to automatically bind matching identifiers:
the compiler finds all valid left/right identifier pairs having the same name and
binds them directly. This is convenient when many bindings are repeated and passed
around. 

\paragraph{Direct access to inputs and outputs.}

The inputs and outputs of instanced algorithms, when not bound,
can be directly accessed using a 'dot' notation. Outputs can be read
and inputs written to.
Example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm algo(input uint8 i,output uint o)
{
  o = i;
}

algorithm main(output uint8 led)
{
  algo a;
  a.i = 131;
  () <- a <- (); // this is a call without explicit inputs/outputs
  led = a.o;
}
\end{minted}



% \todo{}



% ----------------------------------------------

\subsection{Call}

Algorithms may be called synchronously or asynchronously, with or without parameters. Only instanced algorithms may be called.

The asynchronous call syntax is as follows:
\begin{minted}[linenos,frame=lines,framesep=2mm,escapeinside=||,mathescape=true]{verilog}
ID <- (|$P_0,...,P_{N-1}$|); // with parameters
ID <- (); // without parameters
\end{minted}
Where \texttt{ID} is the instanced algorithm name.
When the call is made with parameters, all have to be specified. The parameters
are given in the same order they are declared in the algorithm being called.
The call without parameters is typically used when inputs are bound or specified
directly. Note that when parameters are bound, only the call without parameters
is possible.

When an asynchronous call is made, the instanced algorithm will start processing at the next clock cycle. The algorithm runs in parallel to the caller and any other instanced algorithm. To wait and obtain the result, the join syntax is used:

\begin{minted}[linenos,frame=lines,framesep=2mm,escapeinside=||,mathescape=true]{verilog}
(|$V_0,...,V_{N-1}$|) <- ID; // with receiving variables
() <- ID; // without receiving variables
\end{minted}



\vspace*{5mm}
\noindent
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
\textbf{Note:} Calling algorithms across clock domains is not yet supported. For such cases, autorun with bindings is recommended.}}

% ----------------------------------------------

\subsection{Subroutines}

Algorithms can contain subroutines. These are local routines that can be called by the algorithm multiple times. A subroutine takes parameters, and has access to the variables, instanced algorithms and instanced modules of the parent algorithm -- however access permissions have to be explicitly given. 
%
Subroutines offer a simple mechanism to allow for the equivalent of local functions, without having to wire all the parent algorithm context into another module/algorithm. Subroutines can also declare local variables, visible only to their scope.

A subroutine is declared as:

\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
subroutine ID(
input TYPE ID
...
output TYPE ID
...
reads ID
...
writes ID
...
readwrites ID
...
)
  DECLARATIONS
  INSTRUCTIONS
  return;
\end{minted}

An example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(output uint8 led)
{
  uint8  a       = 1;

  subroutine shift_led(readwrites a) {
    a = a << 1;
    if (a == 0) {
      a = 1;
    }
    return;
  }

  subroutine wait() {
    uint20 counter = 0;
    while (counter != 0) {
      counter = counter + 1;
    }
    return;
  }
    
  led := a;
  
  while(1) {
    () <- wait <- ();
    () <- shift_led <- ();
  }
}
\end{minted}

\noindent \textit{Subroutines permissions.} Subroutine permissions ensure only those variables given read/write
permission can be manipulated. This mitigates the fact that a subroutine may directly manipulate variables in the 
parent algorithm. The format for the permissions is a comma separated list using keywords \texttt{reads}, \texttt{writes}, \texttt{readwrites} \\

\noindent \textit{Why subroutines?} There is a fundamental difference between a subroutine and an algorithm called from 
a host: the subroutine never executes in parallel, while a child algorithm could. However, if this parallelism is not necessary, 
subroutines offer a simple mechanism to repeat internal tasks.\\~

\noindent \textit{Global subroutines} Subroutines may be declared outside of an algorithm. Such subroutines are called \textit{global} and may be called from any algorithm. This is convenient to share subroutines across algorithms. If a global subroutine requests access to parent algorithm variables (read/write permissions), an algorithm calling the subroutine has to have a matching set of variables in its scope. Note that global subroutines are not technically shared, but rather copied in each calling algorithm's scope at compile time.

% ----------------------------------------------

\subsection{Combinational loops}

When writing code, you may encounter a case where the \silice{} compiler
raises an error due to an expression leading to a combinational loop. This
indicates that the sequence of operations is leading to a cyclic dependency
in the combinational chain. These are in most
cases undesirable as they lead to unpredictable hardware behaviors.

A trivial solution is such a situation is to split the combinational chain
using the \textit{step} operator (see Section~\ref{sec:step}). However,
doing so automatically would introduce sequencing 'behind the curtain'
which we absolutely avoid in \silice{}, as this can lead to all sort of synchronization issues (see Section~\ref{sec:execflow} for more information). 
Instead, an error is reported and you are invited to either manually add
a step, or to revise the code. In many cases a slight rewrite avoids the
issue entirely.

\vspace*{2mm}
\noindent Example of a combinational loop:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
  uint8 a = 0;
  a = a + 1; // triggers a combinational loop error
}
\end{minted}

So what happens? It might seem that \texttt{a = a + 1} is the problem here, as it writes as a cyclic dependency. In fact, that is not the sole cause. On its own, this expression is perfectly fine: for each variable \silice{} tracks to versions, the one of the previous clock tick and the one of the current. So \texttt{a = a + 1} in fact means $a_{current} = a_{previous} + 1$.

The problem here comes from the initialization of $a$, in the declaration. This already set a new value to $a_{current}$, and thus the next expression \texttt{a = a + 1} would have to use this new value (otherwise it would be ignored entirely!). This now leads to $a_{current} = a_{current} + 1$ which this time is a combinational loop.

\vspace*{2mm}
\noindent The solution is simple:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
  uint8 a = 0;
  ++: // wait one cycle
  a = a + 1; // now this is fine
}
\end{minted}

It would be difficult to manually keep track of all these potential chains, which is why \silice{} does it for you! In practice, such loops are rarely encountered, and in most cases easily resolved with slight changes to arithmetic and logic.

\vspace*{5mm}
\noindent
\fbox{Note: combinational loops \textit{across} algorithms  (i.e. through \texttt{output!}) are currently not detected.}

% ----------------------------------------------

\subsection{Continuous assignments}

After declarations, optional continuous assignments can be specified.
These use the operators defined in Section~\ref{sec:contassign}.
%
Continuous assignments allow to track the value of an expression
in a variable, output, or instanced algorithm input or output.

\noindent Example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(output uint8 led)
{
  uint8 r = 0;
  adder ad1;

  led   := r;
  ad1.a := 1;
}
\end{minted}

\noindent These assignments are performed at each clock cycle and are order dependent. For instance:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
b := a;
c := b;
\end{minted}
is not the same as:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
c := b;
b := a;
\end{minted}
In the first case, c will immediately take the value of a, while in the second case
c will take the value of a after one clock cycle. This is useful, for instance, when
crossing a clock domain as it allows to implement a two stages flip-flop. In fact,
\silice{} provides a shortcut for exactly this purpose, making the temporary variable b unnecessary:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
c ::= a;
\end{minted}

% ----------------------------------------------

\subsection{Clock and reset}

All algorithms receive a \texttt{clock} and \texttt{reset} signal from their
parent algorithm. These are intrinsic variables, are always defined within
the scope of an algorithm and have type \texttt{int1}. The clock and reset
can be explicitly specified when an algorithm is instanced (Section~\ref{sec:instantiation}).

% ----------------------------------------------

\subsection{Modifiers}

Upon declaration, modifiers can be specified (see \texttt{<MODS>}) in the declaration). This is a comma separated list of any of the following:

\begin{itemize}
	\item \textbf{Autorun.} Adding the \texttt{autorun} keyword will ask the compiler to run the algorithm upon instantiation, without waiting for an explicit call.
	\item \textbf{Internal clock.} Adding a \texttt{@ID} specifies the use of an internally generated clock signal. It is then expected that the algorithm contains a \texttt{int1 ID = 0;} variable declaration, which is bound to the output of a module producing a clock signal. This is meant to be used together with \verilog{} PLLs, to produce new clock signals. The module producing the new clock will typically take \texttt{clock} as input and \texttt{ID}
	as output.
	\item \textbf{Internal reset.} Adding a \texttt{!ID} specifies the use of an internally generated reset signal. It is then expected that the algorithm contains a \texttt{int1 ID = 0;} variable declaration, which is bound to the output of a module producing a reset signal. This may be used, for instance, to filter the signal from a physical reset button.
\end{itemize}

Here is an example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
  algorithm main(output int1 b) <autorun,@new_clock>
  {
    int1 new_clock = 0;

    my_pll pll(
      base_clock <: clock,
      gen_clock :> new_clock
    );

    // the main algorithm is sequenced by new_clock
    // ...
  }
\end{minted}

Which signals are allowed as clocks and resets depends on the FPGA architecture
and vendor toolchain.


% ----------------------------------------------

\section{Execution flow}
\label{sec:execflow}

Upon compilation, \silice{} breaks down the code into a finite state machine (FSM) and corresponding combinational chains.
%
\silice{} attempts to form the longest combinational chains, or equivalently
to minimize the number of states in the FSM. That is because going from one state 
to the next requires one clock cycle, delaying further computations. 
%
Of course, longer combinational chains also lead to reduced clock frequency, so
there is a tradeoff. This is why \silice{} lets you explicitly specify where to cut a combinational chain using the step operator \texttt{++:}

\subsection{The {step} operator}
\label{sec:step}

Placing a \texttt{++:} in the sequence of operations of an algorithm explicitly asks \silice{} to wait for exactly one cycle at this precise location in the execution flow. Each next \texttt{++:} waits one additional cycle.

This has several important applications such as waiting for a memory read/write, or breaking down long combinational chains that would violate timing.



% https://www.xilinx.com/support/documentation/sw_manuals/xilinx2015_2/sdsoc_doc/topics/calling-coding-guidelines/concept_pipelining_loop_unrolling.html
%
% pipelining
%
% for (...) {
%   A(i)   what if A(i) uses C(i-1) ?? => cannot pipeline ...
%   ++:
%   B(i)   written by A, read by B => preserve
%   ++:
%   C(i)   written by A or B, read by C => preserve
% }
%
% for (...) {
%   A(i) [write for B(i),C(i)], B(i-1) [write for C(i-1)], C(i-2) [write for A(i+1)]
%   ++:
% }
%
% unrolling
% 

% ----------------------------------------------

\subsection{Control flow}

The core control flow operations are \texttt{goto}, \texttt{call} and \texttt{return} (\texttt{call} is a \texttt{goto} preparing a return address for \texttt{return}). 
%
While \texttt{goto} and \texttt{call} may be used directly, it is recommended to prefer higher level primitives such as \texttt{while} and subroutines, because \texttt{goto} often lead to harder to read and maintain code\footnote{See the famous Dijkstra's paper about this~\cite{dijkstra}}. Yet, they are a fundamental low-level operation and \silice{} is happy to expose them for your enjoyment!

\texttt{goto} and \texttt{call} always require one cycle to 'jump': this is a change of state in the FSM. Entering a \texttt{while} takes one cycle and then, if there is a single combinational chain inside, it takes exactly one cycle per iteration. 

Now, \texttt{if-then-else} is slightly more subtle. When applied to sequences of operations not requiring any control flow, an \texttt{if-then-else} synthesizes to a combinational \texttt{if-then-else}. This means that both the 'if' and 'else' code are evaluated in parallel as combinational chains, and a multiplexer selects which one is the result based on the condition. This applies recursively, so combinational \texttt{if-then-else} may be nested.

When the \texttt{if-then-else} contains additional control flow (e.g. a subroutine call, a \texttt{while}, a \texttt{++:}, a \texttt{goto}, etc.) it is automatically split into several states of the FSM. It then takes one cycle to exit the 'if' or 'else' part and resume operations. This applies to both 'if' and 'else' even if only one requires control flow while the other is a single combinational chain.

% ----------------------------------------------

\subsection{Cycle costs of calls to algorithms and subroutines}

\todo{subroutine: one cycle to jump to, one cycle to return from}

% ----------------------------------------------

\subsection{Pipelining}



% ----------------------------------------------

\section{Lua preprocessor}

A preprocessor allows to change the way the source code is seen by the compiler.
It sits between the input source code and the compiler, and basically rewrites the
original source code in a different way, before it is input to the compiler.
This allows compile-time behaviors, such as adapting the code to a target platform.

Having a strong preprocessor is important for hardware design. For instance,
designing a sort network of some size $N$ is best done by generating the code 
automatically from a preprocessor, so that one can easily reuse the
same code for different values of $N$. The same is true of a division 
algorithm for some bit width, or for the pre-computations of lookup tables.

The \silice{} preprocessor is built above the Lua language~\url{https://lua.org}. Lua is an amazing powerful, lightweight scripting language that originated in the Computer Graphics community. The preprocessor is thus not just a macro system, but a fully fledged programming language.

\subsection{Principle and syntax}

Preprocessor code is directly interleaved with Silice code. At any point, the source code can be escaped to the preprocessor by starting a line with \$\$. The full line is then considered as preprocessor Lua code. 

The pre-processor sees Silice source lines as strings to be output. 
Thus, it outputs to the compiler any line that is met during the execution
of the preprocessor. This means it does not output those that are not reached, and
it outputs multiple times those that appear in a loop.

Let's make a quick example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{

$$if true then
  uint8 a=0;
  uint8 b=0;
$$end

$$if false then
uint8 c=0;
$$end

$$for i=0,1 do
b = a + 1;
$$end
}
\end{minted}

The code output by the preprocessor is:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{

uint8 a=0;
uint8 b=0;

b = a + 1;
b = a + 1;

}
\end{minted}

Note that source code lines are either fully Silice, of fully preprocessor (starting with \$\$). A second syntax allows to use preprocessor variables directly in Silice source code, simply doing \$\texttt{varname}\$ with \texttt{varname} the variable from the preprocessor context. In fact, a full Lua expression can be used in between the \$ signs; this expression is simply concatenated to the surrounding Silice code.

Here is an example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
$$for i=0,3 do
uint8 a_$i$ = $100+i$;
$$end
}
\end{minted}

The code output by the preprocessor is:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
uint8 a_0 = 100;
uint8 a_1 = 101;
uint8 a_2 = 102;
uint8 a_3 = 103;
}
\end{minted}


\subsection{Includes}

The preprocessor is also in charge of including other Silice source code files,
using the syntax \texttt{\$include('source.ice')}. This loads the entire file
(and recursively its own included files) into the preprocessor execution context.

% ----------------------------------------------

\section{Interoperability with \verilog{} modules}

\silice{} can inter-operate with \verilog{}.

\verilog{} source code can be included in two different ways: \texttt{append('code.v')} and \texttt{import('code.v')} where \texttt{code.v} is a \verilog{} source code file.

\subsection{Append}

Append is very simple: the \verilog{} source code is directly appended to the output of the compiler (which is a \verilog{} source code) without any processing. This makes this \verilog{} code available for other \verilog{} modules, in particular those that are imported (see next). The reason for \texttt{append} is that \silice{} is currently not able to fully parse \verilog{} when importing. 

\subsection{Import}

Import is the most interesting way to inter-operate with \verilog{}.
Once imported, all \verilog{} modules from the \verilog{} source file 
will be available for inclusion in algorithms.

The modules are instantiated in a very similar way as algorithms, with bindings to variables. However, modules cannot be called like algorithms, and the 'dot' syntax to read/write outputs and inputs is not available for modules.

\subsection{Wrapping}

Due to the fact that \silice{} only understands a subset of \verilog{}, there
are cases where a module cannot be imported directly. In such cases, wrapping
offers a solution. The idea is to write a simpler \verilog{} module that can be imported by \silice{} and wraps the instantiation of the more complex one.

Then the complex module is included with \texttt{append} and the wrapper with \texttt{import}.

% ==============================================

\section{Host hardware frameworks}
\label{sec:host}

The host hardware framework typically consists in a \verilog{} glue file. The framework is appended to the compiled \silice{} design (in \verilog{}). The framework instantiates the \textit{main} algorithm. The resulting file can then be processed by the vendor or open source FPGA toolchain (often accompanied by a hardware constraint file).

\silice{} comes with the following host hardware frameworks:
\begin{itemize}
	\item \textbf{mojo\_basic} : framework to compile for the Alchitry Mojo 3 FPGA board.
	\item \textbf{mojo\_hdmi\_sdram} : framework to compile for the Alchitry Mojo 3 FPGA board equipped with the HDMI shield.
	\item \textbf{icestick} : framework for the Lattice ice40 icestick board.
	\item \textbf{verilator\_vga} : framework for use with \textit{verilator}
	\item \todo{update with icarus, as well as bare versions, mention sdram emulator}
\end{itemize}

For practical usage examples please refer to the \textit{Getting started} guide. \todo{ + guide url}

% ==============================================
	
\end{document}
